# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1)#
	while (status(state[1],state[2]) == "unfinished"){#
		# show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3==2]) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)
play_game(.5,.5)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1)#
	while (status(state[1],state[2]) == "unfinished"){#
		# show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)
play_game(.5,.5)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1)#
	while (status(state[1],state[2]) == "unfinished"){#
		show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)
play_game(.5,.5)
play_game(.5,.5)
play_game(.5,.5)
play_game(.5,.5)
play_game(.5,.5)
play_game(.5,.9)
play_game(.9,.9)
play_game(.1,.9)
play_game(.1,.1)
play_game(.1,.9)
play_game(.5,.9)
play_game(.5,.5)
play_game(.5,0)
play_game(.5,0)
play_game(.5,0)
play_game(.5,0)
play_game(.5,0)
play_game(.5,1)
play_game(.5,.1)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1)#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1)#
	while (status(state[1],state[2]) == "unfinished"){#
		show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
set.seed(seed)#
play_game(.5,.5)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
play_game(.55,.45)
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
play_game(.55,.45)
rep(play_game(.55,.45),2)
rep(play_game(.55,.45),1024)
play_game(0,1)
play_game(.1,1)
play_game(.1,1)
play_game(.9,1)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
set.seed(seed)
play_game(.9,.4)
play_game(.9,.4)
play_game(.9,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
play_game(.5,.4)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
rep(play_game(.55,.45),1024)
repeat
()
?repeat
()
?repeat()
lapply(play_game)
lapply(1,play_game)
lapply(.55,play_game)
lapply(c(.55,.45),play_game)
?lapply
lapply(rep(c(.55,.45),10),play_game)
apply
mapply(play_game,.55,.45)
mapply(play_game,rep(.55,10),rep(.45,10)
mapply(play_game,rep(.55,10),rep(.45,10))
mapply(play_game,rep(.55,10),rep(.45,10))
mapply(play_game,rep(.55,10),rep(.45,10))
mapply(play_game,rep(.55,1024),rep(.45,1024))
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
mapply(play_game,rep(.55,i),rep(.45,i))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(sum(mapply(play_game,rep(.55,i),rep(.45,i)))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(sum(mapply(play_game,rep(.55,i),rep(.45,i))))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(mapply(play_game,rep(.55,i),rep(.45,i))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(mapply(play_game,rep(.55,i),rep(.45,i)))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i))))#
}
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
for(i in 1:12){#
print(sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i))))#
}
probabilities <- rep(NA,12)
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
for(i in 1:12){#
probabilities[i] <- sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i))))/i#
}
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
for(i in 1:12){#
probabilities[i] <- sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i)))/i#
}
probabilities
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
for(i in 1:12){ # this will take a while#
probabilities[i] <- sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i)))/2^i#
}
probabilities
lapply(sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i)))/2^i)
lapply(1:12,sum(mapply(play_game,rep(.55,2^i),rep(.45,2^i)))/2^i)
i
lapply(1:12,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x)}
lapply(1:12,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})
#
sapply(1:3,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
# this will take a while#
probabilities <- sapply(1:3,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})
probabilities
probabilities <- rep(NA,12)
probabilities
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
# this will take a while#
probabilities <- sapply(1:12,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})
probabilites
probabilities
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
# this will take a while#
probabilities <- sapply(1:12,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
probabilities
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,20)#
# this will take a while#
probabilities <- sapply(1:20,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
probabilities
# ###
# spa1_q2_tn248.R#
# Do this!#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 27 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
# To-do:#
# Script header#
# The whole problem lololol#
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,13)#
# this will take a while#
probabilities <- sapply(1:13,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
probabilities
# The seed is my birthday, in American date form.#
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,14)#
# this will take a while#
probabilities <- sapply(1:14,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
probabilities
seed <- 110685#
set.seed(seed)#
#
# Some games#
#
probabilities <- rep(NA,12)#
# this will take a while#
probabilities <- sapply(1:12,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
probabilities
plot(1:sample.size, probabilities)
sample.size <- 12
plot(1:sample.size, probabilities)
#
plot(1:sample.size, probabilities)#
main <- "Estimated probability for different sample sizes"
main("Estimated probability for different sample sizes")
#
plot(1:sample.size, probabilities,main="Estimated probability for different sample sizes")
#
plot(1:sample.size, probabilities,main="Estimated probability for different sample sizes", xlabel="log(n)/log(2)", ylabel="p_hat")
warnings()
?plot
#
plot(1:sample.size, probabilities,main="Estimated probability for different sample sizes", xlab="log(n)/log(2)", ylab="p_hat")
seq(.1,.9,by=.1)
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
sum(mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1)))
#
mapply(play_game,seq(.1,.9,by=.1),seq(.1,.9,by=.1))
rep(.1,.9,by=.1,each=.9)
rep(.1,.9,by=.1,each=9)
rep(.1,.9,by=.1)
rep(.1,.9,by=.1,each=12)
rep(seq(.1,.9,by=.1),each=12)
rep(seq(.1,.9,by=.1),each=9)
cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),each=9))
cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),9))
mapply(play_game,p.hat.values[,1],p.hat.values[,2])
p.hat.values <- cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),9))
mapply(play_game,p.hat.values[,1],p.hat.values[,2])
#
mapply(function(x,y){sum(mapply(play_game,rep(x,2^10),rep(y,2^10)))/2^10,p.hat.values[,1],p.hat.values[,2])
#
mapply(function(x,y){sum(mapply(play_game,rep(x,2^10),rep(y,2^10)))/2^10,p.hat.values[,1],p.hat.values[,2]})
#
mapply(function(x,y){sum(mapply(play_game,rep(x,2^10),rep(y,2^10)))/2^10},p.hat.values[,1],p.hat.values[,2])
mapply(function(x,y){sum(mapply(play_game,rep(x,2^5),rep(y,2^5)))/2^5},p.hat.values[,1],p.hat.values[,2])
seed <- 110685#
set.seed(seed)#
#
# Estimating probability for different sample sizes#
sample.size <- 12#
probabilities <- rep(NA,sample.size)#
#
# this will take a while#
probabilities <- sapply(1:sample.size,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
#
plot(1:sample.size, probabilities,main="Estimated probability for different sample sizes", xlab="log(n)/log(2)", ylab="p_hat")#
#
# Table of estimated p(a,b) values#
resolution <- 5#
p.hat.values <- cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),9))#
#
mapply(function(x,y){sum(mapply(play_game,rep(x,2^resolution),rep(y,2^resolution)))/2^resolution},p.hat.values[,1],p.hat.values[,2])
?matrix
matrix(mapply(function(x,y){sum(mapply(play_game,rep(x,2^resolution),rep(y,2^resolution)))/2^resolution},p.hat.values[,1],p.hat.values[,2]),9,9)
p.hat.values
?matrix
#
matrix(mapply(function(x,y){sum(mapply(play_game,rep(x,2^resolution),rep(y,2^resolution)))/2^resolution},p.hat.values[,1],p.hat.values[,2]),9,9,byrow=TRUE)
#
matrix(mapply(function(x,y){sum(mapply(play_game,rep(x,2^resolution),rep(y,2^resolution)))/2^resolution},p.hat.values[,1],p.hat.values[,2]),9,9,byrow=TRUE)
?set.seed
sqrt
sqrt(.01)
5000-5000^2
*.1
5000-5000^2
-24995000*.1
.99-.99^2
.0099*.1
.01*.01
.0001 == 1e-04
.5*.5
.25/.0001
.5/.0001
.5*.5
.25/.001
# Table of estimated p(a,b) values#
resolution <- 2500#
p.hat.values <- cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),9))#
#
# This one-liner will create a table of p.hats by simulating 2^resolution#
# games for each pair in p.hat.values. Might take a while depending on#
# resolution.#
p.hat.table <- matrix(mapply(function(x,y){sum(mapply(play_game,rep(x,resolution),rep(y,resolution)))/resolution},p.hat.values[,1],p.hat.values[,2]),9,9,byrow=TRUE)
# ###
# spa1_q2_tn248.R#
# This script will simulate a game of squash.#
# It will then simulate many games of squash, and plot#
# some p.hat estimations.#
# ###
#
# ###
# Created 27 Oct 2010#
# Last updated 28 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
library(spuRs)#
#
# The following two functions were taken from the spuRs#
# package, a companion to Scientific Programming Using R #
# by Jones, Maillardet, and Robinson.#
#
status.test <- function(s.ftn){#
	x.vec <- (-1):11#
	y.vec <- (-1):11#
	plot(x.vec, y.vec, type = "n", xlab="x",ylab="y")#
	for(x in x.vec){#
		for(y in y.vec){#
			s <- s.ftn(x,y)#
			if (s == "impossible") text(x,y,"X",col="red")#
			else if (s == "unfinished") text(x,y, "?", col="blue")#
			else if (s == "player 1 win") text(x,y,"1", col="green")#
			else if (s == "player 2 win") text(x,y,"2", col="green")#
			}#
		}#
	return(invisible(NULL))#
}#
#
play_game<- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(TRUE)#
	} else{#
		return(FALSE)#
	}#
}#
#
# The rest is mine.#
#
status <- function(x,y){#
	if (x < 0 | y < 0 | (x > 9 & x-y > 2) | (y > 9 & y-x >2)){#
		return("impossible")}#
	else if((x == 9 & x-y >= 2) | (x > 9 & x-y == 2)){#
		return("player 1 win")}#
	else if((y == 9 & y-x >= 2) | (y > 9 & y-x == 2)){#
		return("player 2 win")}#
	else{return("unfinished")}#
	}#
#
play_point <- function(state,a,b){#
	# for my reference:#
	# state = (x,y,z)#
	# x is player 1's score#
	# y is player 2's score#
	# z indicates whose serve#
	# a is probability 1 wins a point when 1 serves#
	# b is probability 1 wins a point when 2 serves#
	if (state[3]==1){#
		odds <- a}#
	else{odds <-b}#
		#
	# the game!#
	point <- rbinom(1,1,odds)#
	#
	if (point == 1){#
		if (state[3]==1) {state[1] <- state[1] + 1}#
		else if (state[3]==2) {state[3] <- 1}#
		}#
	else if (point == 0){#
		if (state[3]==1) {state[3] <- 2}#
		else if (state[3]==2) {state[2] <- state[2] +1}#
		}#
	#
	return(state)#
	}#
#
# The seed is my birthday, in American date form. #
# Set once and only once.#
seed <- 110685#
set.seed(seed)#
#
# Estimating probability for different sample sizes#
sample.size <- 12#
probabilities <- rep(NA,sample.size)#
#
# this will take a while#
probabilities <- sapply(1:sample.size,function(x){sum(mapply(play_game,rep(.55,2^x),rep(.45,2^x)))/2^x})#
#
plot(1:sample.size, probabilities,main="Estimated probability for different sample sizes", xlab="log(n)/log(2)", ylab="p_hat")#
#
# Table of estimated p(a,b) values#
resolution <- 2500#
p.hat.values <- cbind(rep(seq(.1,.9,by=.1),each=9),rep(seq(.1,.9,by=.1),9))#
#
# This one-liner will create a table of p.hats by simulating #
# games for each pair in p.hat.values. Might take a while depending on#
# the resolution.#
p.hat.table <- matrix(mapply(function(x,y){sum(mapply(play_game,rep(x,resolution),rep(y,resolution)))/resolution},p.hat.values[,1],p.hat.values[,2]),9,9,byrow=TRUE)#
#
play_game_length <- function(a,b){#
	state <- c(0, 0, 1) # player 1 serves first#
	count <- 0#
	while (status(state[1],state[2]) == "unfinished"){#
		#show(state)#
		state <- play_point(state, a, b)#
		count <- count + 1#
		}#
	if (status(state[1],state[2]) == "player 1 win"){#
		return(count)#
	} else{#
		return(count)#
	}#
}
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
play_game_length(.45,.55)
resolution <- 25
#
length.table <- matrix(mapply(function(x,y){sum(mapply(play_game_length,rep(x,resolution),rep(y,resolution)))/resolution},p.hat.values[,1],p.hat.values[,2]),9,9,byrow=TRUE)
length.table
2^12
# ###
# spa1_q1_tn248.R#
# This script will compile scores, grades, and ranks for #
# an arbitrary number of students and their exam answers.#
# It will also spot cheating by pairwise comparing students'#
# answers and results.#
# ###
#
# ###
# Created 14 Oct 2010#
# Last updated 24 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
num.students <- 12 # Adjustable#
num.questions <- 30 #Adjustable#
 #
crib <- cbind(c(1:100),read.table("crib.dat"))#
colnames(crib)<- c("qn","response")#
rubric <- read.table("grade.txt",header=TRUE)#
#
# initialize everything#
student.index <-1:num.students#
correct <-rep(NA,num.students)#
rank<-rep(NA,num.students)#
#
students <- lapply(1:num.students,function(x){read.table(paste("student", toString(x),".dat",sep=""),header=TRUE)})#
#
correct <- sapply(1:num.students,function(x){sum(students[[x]]$response == crib[students[[x]]$qn,]$response)})#
#
number <- sapply(1:num.students,function(x){floor(100*correct[[x]]/num.questions)})#
#
alpha.grades <- sapply(1:num.students,function(x){rubric$grade[which((rubric$min <= number[[x]]) == (number[[x]] <= rubric$max), TRUE)]})#
#
results <- data.frame(student=student.index,score=correct,grade=alpha.grades,rank=rank)#
#
# assign ranks#
results.sort<- results[order(results$score),]#
results.sort$rank<-c(12:1)#
#
# sort it back#
results <- results.sort[order(results.sort$student),]#
results#
summary(results$score)#
#
####
# cheater catcher function#
####
# usage: cheaterkiller(i,j), where i and j are #
# the numbers of the suspected students#
# #
# I had considered preloading all students before using #
# this function, but I think this is more memory efficient.#
#
cheaterkiller <- function(i,j){ #
	#
student.i <- read.table(paste("student", toString(i),".dat",sep=""),header=TRUE)#
student.j <- read.table(paste("student", toString(j),".dat",sep=""),header=TRUE)#
#
# which questions did they both attempt and how similar are the answers?#
similarqs <- intersect(student.i$qn,student.j$qn)#
#
#order by questions#
student.i <- student.i[order(student.i$qn),]#
student.j <- student.j[order(student.j$qn),]#
#
#one-line to compare students' answers#
similaras <- student.i$response[which(student.i$qn %in% similarqs)] == student.j$response[which(student.j$qn %in% similarqs)]#
#
return(sum(similaras))#
	}#
	#
####
# Finding the cheater; only calculates lower diagonal of matrix#
####
#
cheatermatrix <- matrix(rep(0,num.students^2),num.students,num.students)#
x <- cbind(rep(1:num.students, each=num.students),rep(1:num.students, num.students))#
x <- x[x[,1] <= x[,2], ]#
cheatermatrix[lower.tri(cheatermatrix,diag=TRUE)]<-mapply(cheaterkiller,x[,1],x[,2])#
cheatermatrix
# ###
# spa1_q1_tn248.R#
# This script will compile scores, grades, and ranks for #
# an arbitrary number of students and their exam answers.#
# It will also spot cheating by pairwise comparing students'#
# answers and results.#
# ###
#
# ###
# Created 14 Oct 2010#
# Last updated 24 Oct 2010#
# tn248@cam.ac.uk#
# ###
#
num.students <- 12 # Adjustable#
num.questions <- 30 #Adjustable#
 #
crib <- cbind(c(1:100),read.table("crib.dat"))#
colnames(crib)<- c("qn","response")#
rubric <- read.table("grade.txt",header=TRUE)#
#
# initialize everything#
student.index <-1:num.students#
correct <-rep(NA,num.students)#
rank<-rep(NA,num.students)#
#
students <- lapply(1:num.students,function(x){read.table(paste("student", toString(x),".dat",sep=""),header=TRUE)})#
#
correct <- sapply(1:num.students,function(x){sum(students[[x]]$response == crib[students[[x]]$qn,]$response)})#
#
number <- sapply(1:num.students,function(x){floor(100*correct[[x]]/num.questions)})#
#
alpha.grades <- sapply(1:num.students,function(x){rubric$grade[which((rubric$min <= number[[x]]) == (number[[x]] <= rubric$max), TRUE)]})#
#
results <- data.frame(student=student.index,score=correct,grade=alpha.grades,rank=rank)#
#
# assign ranks#
results.sort<- results[order(results$score),]#
results.sort$rank<-c(12:1)#
#
# sort it back#
results <- results.sort[order(results.sort$student),]#
results#
summary(results$score)#
#
####
# cheater catcher function#
####
# usage: cheaterkiller(i,j), where i and j are #
# the numbers of the suspected students#
# #
# I had considered preloading all students before using #
# this function, but I think this is more memory efficient.#
#
cheaterkiller <- function(i,j){ #
	#
student.i <- read.table(paste("student", toString(i),".dat",sep=""),header=TRUE)#
student.j <- read.table(paste("student", toString(j),".dat",sep=""),header=TRUE)#
#
# which questions did they both attempt and how similar are the answers?#
similarqs <- intersect(student.i$qn,student.j$qn)#
#
#order by questions#
student.i <- student.i[order(student.i$qn),]#
student.j <- student.j[order(student.j$qn),]#
#
#one-line to compare students' answers#
similaras <- student.i$response[which(student.i$qn %in% similarqs)] == student.j$response[which(student.j$qn %in% similarqs)]#
#
return(sum(similaras))#
	}#
	#
####
# Finding the cheater; only calculates lower diagonal of matrix#
####
#
cheatermatrix <- matrix(rep(0,num.students^2),num.students,num.students)#
x <- cbind(rep(1:num.students, each=num.students),rep(1:num.students, num.students))#
x <- x[x[,1] <= x[,2], ]#
cheatermatrix[lower.tri(cheatermatrix,diag=TRUE)]<-mapply(cheaterkiller,x[,1],x[,2])#
cheatermatrix
results
